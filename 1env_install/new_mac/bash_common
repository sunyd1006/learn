#!/bin/bash

# 使用 BASH_SOURCE[0] 获取当前文件的路径
scriptdir="$(cd "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"

# ============  shell config
function appendPathIfNotExits() {
    pathItem=$1
    if [[ ":$PATH:" != *":$pathItem:"* ]]; then
        export PATH=$pathItem:$PATH
        # echo "appendPathIfNotExits: $pathItem"
    fi
}

function load_config_from_learn() {
  if [[ ${HOME} == "/Users/sunyindong" ]]; then
    syd_dir="$HOME"  # local m1 mac
  elif [[ ${HOME} == "/Users/sunyindong.syd" ]]; then
    syd_dir="$HOME"  # correct mac
  elif [[ ${HOME} == "/Users/bytedance" ]]; then
    syd_dir="$HOME"  # correct bytedance
  elif [[ ${HOME} == "/home/sunyindong" ]]; then
    syd_dir="$HOME"  # correct bytedance
  else
    syd_dir="${HOME}/sunyindong.syd"
  fi
  mkdir -p ${syd_dir}/codespace
  # 主要存储公司的tool
  toolPath=${syd_dir}/tool
  mkdir -p ${toolPath}
  appendPathIfNotExits ${toolPath}
}
load_config_from_learn

export LEARN="${syd_dir}/codespace/learn"
bash_common="${LEARN}/1env_install/new_mac/bash_common"

source ${LEARN}/0lib/shell/common.sh
log_info "\n\n========== Bash 配置 ==========\n1env_install/new_mac/bash_common loaded! \n"


# === 个人配置整理
prepare_bash_config() {
    # ========== 配置文件路径和内容定义 ==========
    # 生效时机：在登录式交互 Shell（Interactive Login Shell）启动时加载。
    # 当 bash 以登录模式启动时（如 ssh 登录、bash -l），会依次检查并加载以下文件中的第一个存在的文件（优先级从高到低）：
    #     ~/.bash_profile
    #     ~/.bash_login
    #     ~/.profile
    local BASH_PROFILE="$HOME/.bash_profile"

    # 当 bash 以非登录模式启动时（如图形终端直接打开、bash 命令手动启动），只加载 ~/.bashrc，不会检查 ~/.bash_profile 等登录配置文件。
    # 优先级：此时 ~/.bashrc 是唯一被加载的配置文件，没有其他文件与其竞争。
    local BASHRC_FILE="$HOME/.bashrc"

    local ZSHRC_FILE="$HOME/.zshrc"

    # 要插入的配置行
    local LOAD_BASHRC="source ~/.bashrc "
    local MYBASHRC_LINE="source ${bash_common}"
    local BASHRC_LOCAL="touch ~/.bashrc.local; source ~/.bashrc.local;"

    # ========== 辅助函数：安全创建软链接 ==========
    create_symlink() {
        local target="$1"
        local link="$2"
        ln -sf "$target" "$link" 2>/dev/null;
    }

    # ========== 1. 确保必要文件存在 ==========
    touch "$BASH_PROFILE" "$BASHRC_FILE" "$ZSHRC_FILE"

    # ========== 2. 配置 ~/.bash_profile 和 ~/.zshrc 加载 ~/.bashrc ==========
    check_and_prepend "$BASH_PROFILE" "$LOAD_BASHRC"
    check_and_prepend "$ZSHRC_FILE"   "$LOAD_BASHRC"

    # ========== 3. 配置 ~/.bashrc 加载自定义配置 ==========
    check_and_prepend "$BASHRC_FILE" "$MYBASHRC_LINE; "
    check_and_append "$BASHRC_FILE"  "${BASHRC_LOCAL}"

    # ========== 4. 创建便于管理的软链接 ==========
    # 查看cwd是否包含learn 和 new_mac 目录，如果不包含，就不创建软链接
    if [[ ${PWD} = *"learn"* && ${PWD} = *"new_mac"* ]]; then
        create_symlink "$BASHRC_FILE" "${scriptdir}/home_bashrc"
        create_symlink "$HOME/.bashrc.local" "${scriptdir}/home_bashrc.local"
    fi

    # ========== 5. 显示配置说明 ==========
    cat << 'EOF'
========== Bash 配置完成
设计说明: 登录shell ~/.bash_profile, 非登录shell ~/.bashrc / ~/.zshrc
sun个人配置上：
  - ~/.bash_profile         → 加载 ~/.bashrc
  - ~/.bashrc 和 ~/.zshrc   → 加载 bash_common + ... +  ~/.bashrc.local + 其他的配置
个人记忆：~/.bash_profile < bash_common < ~/.bashrc.local < ~/.bashrc 剩余配置 (后加载的优先级更高)
==================================

EOF
}
# 为了避免bashrc->bash_common->bashrc 循环加载，所以在bash_common中只加载一次bashrc
# 在环境变量LOAD_FIRST 为true时，才执行函数
if [[ ${LOAD_FIRST} == "true" ]]; then
    prepare_bash_config
fi
alias vibashrc="vi ${bash_common}"
alias mysource="source ~/.bashrc "
alias vilocal="vi ~/.bashrc.local"

alias cdsyd="cd ${syd_dir}/"
alias cdcode="cd ${syd_dir}/codespace/"
alias cdtool="cd ${syd_dir}/tool/"
alias cdlearn="cd ${LEARN}"

# 2. my machine config
alias ll="ls -al"                   # yymmddhhmm ：指定年月日时分，如 17022318 表示2017年2月23日18时
alias myhalt="sudo shutdown -h"            # hh:mm ：今天某时某分
alias myrestart="sudo shutdown -r"          # +n ：n分钟后
alias mysleep="sudo shutdown -s"           # now：现在
alias print="printf '\e[?2004l' "


# 2. cd alias
# alias for dir、quick command、
alias cddesktop="cd ~/Desktop"
alias cddown="cd && cd ./Downloads"
alias cddocu="cd && cd ./Documents"
alias cdenv="cd && cd ./environment"
alias cdwork="cd && cd ./workspace"
alias cdcode="cd && cd ./codespace"
alias cdjava="cdcode && cd ./TestJava"
alias cdcom="cdcode && cd ./company"
alias cdtest="cdcode && cd  ./test"
alias cdnotes="cddesktop && cd notes"

alias cdlearn="cdcode && cd ./learn"
alias cdcpp="cdcode && cd ./learn/test_cpp"

# github dns
alias vihosts="sudo vim /etc/hosts"
alias cathosts="cat /etc/hosts"
alias flushdns="sudo killall -HUP mDNSResponder"


# 2. git config
alias gst="git status "
alias ga="git add "
alias gcm="git commit -m "
alias gcam="git commit --amend "
alias gco="git checkout "
alias gcob="git checkout -b"

alias gcp="git cherry-pick "

alias gbr="git branch "
alias gl="git log "
alias gls="git log --oneline -S "
alias glg="git log --graph --decorate --oneline --all"

alias gc="git clean "
alias gr="git restore "

alias gd="git diff"
alias gbr="git branch"

alias gge="git grep -e"
alias ggn="git grep -n"


# == 3. 个人运维脚本
# bash cannot define command params, so i define a function to use it.
# lsof: list of file, -t: only pid, -i: only file realted to internet
alias killport='killport() { kill -9 $(lsof -t -i:$1) }; killport'


# ag grep
alias ag="ag --group"
alias agc="ag -C "
alias ag3="ag -C 3 "
alias ag4="ag -C 4 "
alias agn="ag      --nogroup "
alias agn3="ag -C 3 --nogroup "

# vim
alias vi="nvim "
alias vim="nvim "

# docker config
# sun add for docker-compose timeout
export COMPOSE_HTTP_TIMEOUT=900
export DOCKER_CLIENT_TIMEOUT=900


# mvn config
alias mvndown="mvn dependency:resolve -Dclassifier=sources"
alias mvndes="mvn deploy -DaltDeploymentRepository=snapshots::default::http://mvnrepo.alibaba-inc.com/mvn/snapshots -Dmaven.test.skip=true -Dgpg.skip"
alias mvnp="mvn clean package"
alias mvnps="mvn clean package -Dmaven.test.skip"
alias mvn_update_snap="mvn clean install -U"
alias mvnrun="mvn spring-boot:run"

function mvndown() {
    mvn dependency:sources
    mvn dependency:resolve -Dclassifier=javadoc
}



# =========== cpp config

alias cc="g++ -std=c++17 -g -pthread "
alias g14="g++ -std=c++14 -g -pthread "
alias g17="g++ -std=c++17 -g -pthread "

# ======= dev_tool
function ms {
    ${LEARN}/1env_install/new_mac/dev_tool/mysync.sh $@
}
